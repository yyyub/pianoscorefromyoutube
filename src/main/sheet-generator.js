const Vex = require('vexflow');
const { createCanvas } = require('canvas');
const puppeteer = require('puppeteer');
const fs = require('fs-extra');
const path = require('path');
const fileManager = require('./file-manager');

class SheetGenerator {
  constructor() {
    this.isCancelled = false;
  }

  async parseMidiFile(midiPath) {
    try {
      // Read MIDI file
      const midiBuffer = await fs.readFile(midiPath);

      // For now, we'll create a simple structure
      // In a full implementation, we'd use a MIDI parsing library
      return {
        notes: [],
        timeSignature: '4/4',
        tempo: 120,
        keySignature: 'C'
      };
    } catch (error) {
      throw new Error(`Failed to parse MIDI file: ${error.message}`);
    }
  }

  async generatePianoStaff(notes, metadata) {
    // Create a canvas for rendering
    const canvas = createCanvas(800, 1100); // Letter size
    const context = canvas.getContext('2d');

    // White background
    context.fillStyle = 'white';
    context.fillRect(0, 0, canvas.width, canvas.height);

    // Initialize VexFlow renderer
    const renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.CANVAS);
    renderer.resize(800, 1100);
    const context2d = renderer.getContext();

    // Create a stave (staff)
    const stave = new Vex.Flow.Stave(10, 40, 780);

    // Add clef, time signature, and key signature
    stave.addClef('treble');
    stave.addTimeSignature(metadata.timeSignature || '4/4');

    // Draw the stave
    stave.setContext(context2d).draw();

    // For demonstration, we'll add some sample notes
    // In a full implementation, this would use the parsed MIDI data
    const voice = new Vex.Flow.Voice({
      num_beats: 4,
      beat_value: 4
    });

    // Add some example notes
    const notes_vex = [
      new Vex.Flow.StaveNote({ keys: ['c/4'], duration: 'q' }),
      new Vex.Flow.StaveNote({ keys: ['d/4'], duration: 'q' }),
      new Vex.Flow.StaveNote({ keys: ['e/4'], duration: 'q' }),
      new Vex.Flow.StaveNote({ keys: ['f/4'], duration: 'q' })
    ];

    voice.addTickables(notes_vex);

    // Format and justify the notes
    const formatter = new Vex.Flow.Formatter();
    formatter.joinVoices([voice]).format([voice], 700);

    // Render voice
    voice.draw(context2d, stave);

    return canvas;
  }

  async createVexFlowScore(notes, metadata) {
    try {
      // Create the piano staff with VexFlow
      const canvas = await this.generatePianoStaff(notes, metadata);
      return canvas;
    } catch (error) {
      throw new Error(`Failed to create score: ${error.message}`);
    }
  }

  async renderToCanvas(score) {
    // The score is already a canvas from VexFlow
    return score;
  }

  async exportToPdf(canvas, outputPath, videoTitle) {
    try {
      // Convert canvas to data URL
      const dataUrl = canvas.toDataURL('image/png');

      // Create HTML with the image
      const html = `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body {
              margin: 0;
              padding: 20px;
              font-family: Arial, sans-serif;
            }
            h1 {
              text-align: center;
              margin-bottom: 20px;
            }
            img {
              max-width: 100%;
              height: auto;
            }
          </style>
        </head>
        <body>
          <h1>${videoTitle || 'Piano Sheet Music'}</h1>
          <img src="${dataUrl}" alt="Sheet Music" />
          <p style="text-align: center; margin-top: 20px; color: #666;">
            Generated by YouTube to Piano Sheet Music
          </p>
        </body>
        </html>
      `;

      // Use puppeteer to convert HTML to PDF
      const browser = await puppeteer.launch({
        headless: 'new',
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });

      const page = await browser.newPage();
      await page.setContent(html, { waitUntil: 'networkidle0' });

      await page.pdf({
        path: outputPath,
        format: 'Letter',
        printBackground: true,
        margin: {
          top: '20px',
          right: '20px',
          bottom: '20px',
          left: '20px'
        }
      });

      await browser.close();

      return outputPath;
    } catch (error) {
      throw new Error(`Failed to export PDF: ${error.message}`);
    }
  }

  async generateSheetMusic(midiPath, videoTitle, progressCallback) {
    this.isCancelled = false;

    const outputFilename = fileManager.sanitizeFilename(`${videoTitle || 'sheet-music'}.pdf`);
    const outputPath = fileManager.getTempPath(outputFilename);

    try {
      if (progressCallback) {
        progressCallback(10, 'Parsing MIDI file...');
      }

      // Parse MIDI file
      const midiData = await this.parseMidiFile(midiPath);

      if (this.isCancelled) {
        throw new Error('Sheet generation cancelled');
      }

      if (progressCallback) {
        progressCallback(30, 'Creating sheet music...');
      }

      // Create VexFlow score
      const score = await this.createVexFlowScore(midiData.notes, midiData);

      if (this.isCancelled) {
        throw new Error('Sheet generation cancelled');
      }

      if (progressCallback) {
        progressCallback(60, 'Rendering to canvas...');
      }

      // Render to canvas
      const canvas = await this.renderToCanvas(score);

      if (this.isCancelled) {
        throw new Error('Sheet generation cancelled');
      }

      if (progressCallback) {
        progressCallback(80, 'Exporting to PDF...');
      }

      // Export to PDF
      await this.exportToPdf(canvas, outputPath, videoTitle);

      if (progressCallback) {
        progressCallback(100, 'PDF generation complete');
      }

      // Move to output directory
      const finalPath = await fileManager.moveToOutput(outputPath, outputFilename);

      return {
        filePath: finalPath,
        filename: outputFilename
      };
    } catch (error) {
      await fileManager.deleteFile(outputPath);

      if (error.message.includes('cancelled')) {
        throw error;
      }

      console.error('Sheet generation error:', error);
      throw new Error(`Sheet generation failed: ${error.message}`);
    }
  }

  cancel() {
    this.isCancelled = true;
  }
}

module.exports = new SheetGenerator();
